    if(p_evt_write->handle == context.control_point_char_handle.value_handle) {        
        senstick_control_command_t currentValue = senstick_getControlCommand();
        if(currentValue != (senstick_control_command_t)gatts_value.p_value[0]) {
            senstick_setControlCommand((senstick_control_command_t)gatts_value.p_value[0]);
        }
    } else 


        if((command & 0x02) != 0) {



名前		サンプリング周期	サービスUUID		
加速度		10ミリ秒以上、100ミリ秒周期か、100ミリ秒以下(10, 20, 50, 100ミリ秒の倍数)
ジャイロ		10ミリ秒以上
湿度		
磁界		10ミリ秒以上
気圧		100ミリ秒以上

照度、独自でOK	200ミリ秒以上、変換に150ミリ秒かかるから。100ミリ秒周期
UV、独自でOK	内部で自動サンプリング、275ミリ秒ごと。なので300ミリ秒以上。100ミリ秒周期
温度湿度		12ミリ秒、9ミリ秒かかる。サンプル周期が10ミリ秒だときつい。->2段階に分けてサンプリングするか、バスを握られないにするか。
		周期、100ミリ秒以上、100ミリ秒周期

本体の状態
動作中 or スリープ

センサ情報の設定、不揮発に。

ボタンの仕様

1回押す、	スリープしていたら、起きる。離したら、新規ログ開始。
2秒押す。   2回ぱっぱっと光る。ここで離すと、スリープ。
5秒長押し、2回ぱぱっと光る。ここで離すと、ログメモリ全クリア。

点滅の仕様
点滅の周期と点滅のパターンで意味を作る
点滅の周期は、1秒と3秒。	接続状態を表す。	接続していれば1秒、していなければ3秒。
点滅のパターン。1回、2回。	1回 動作しているけど、ロギングはしていない。 2回、ロギングしている。3回、ログの容量不足。いっぱい、いっぱい。

ロギングの仕様
センサータグは、常にデータを取り続ける。
サンプリング周期の設定を変更すれば、異なるログとなる。
ログはID番号で指定する。

ログは、データユニット(0-99)の単位で管理される。
データユニットは、ヘッダ情報と、設定に従ってサンプルされたセンサーデータの配列で構成される。
ヘッダ情報には、センサーのサンプリング周期、日時、概要テキストが記録される。
センサデータの配列は、I2Cで読み取った構造体そのもの。

ベースUUID
F000xxxx-0451-4000-B000-000000000000
アドバタイジングするサービスUUID、コントロールサービス(0x2000)をアドバタイジングします。
F000bb00-0451-4000-B000-000000000000

16-bit UUIDの割当範囲 (BLEの仕様に従う)
0x1800 から 0x26FF: サービスUUID
0x2A00 から 0x7FFF: キャラクタスティクス

== senstick control service == 
UUID: 0x2000
0x7000, ステータス/コントロールポイント, read, write, indication
	1. 1バイト		enum, 動作指示, write
				0x00 センサスリープ、BLE動作
				0x01 センシング(ログ)中
				0x10 ストレージフォーマット中
				0x20 ディープスリープに入る(スイッチを押して再起動)
				0x40 DFUモードに入る
0x7001, 有効ログの数, read, notify
	1バイト		記録中を含む有効なデータがあるログの数を示します。最初は0。
0x7002, ストレージステート, read, notify
	1バイト		ログなどのエラー状態。0x00なら正常、0x01ならディスクフル。記録不可能。フォーマットすべし。
0x7003, メタ属性時間, read, write
	ロギングをスタートした時に書き込まれる、時刻。RTCで内部で勝手に管理される。
	https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.date_time.xml
	1. 7バイト	日時
			be_date_timeのフォーマット。
			リトルエンディアンでuint16_tで年、あとはint8_tで、月、日にち、時間、分、秒
			1. lsb_year 
			2. msb_year, 2016年など値がそのまま入る。0はunknown
			3. 月 1-12, 0 はunknown
			4. 日 1-31, 0はunknown
			5. 時間, 0 - 23, 
			6. 分 0 - 59
			7. 秒 0 - 59
0x7004, メタ属性:概要、read, write
	ロギングをスタートした時に書き込まれる、ログの概要テキスト
	1. 20バイト	テキスト, 0ターミナルは不要。もしもテキストがない場合は0x0

== メタデータ読み出しサービス ==
UUID: 0x2001
0x7010, 読み出し対象ログID、read, write
	1バイト uint8_t ログID
0x7011, メタ属性時間, read
	有効な値がない場合は、空配列[]
0x7012, メタ属性:概要, read
	有効な値がない場合は 空配列[]

== sensor service (base type) ==
センサーごとに、リアルタイムのデータ取得とログの読み出しの機能が1つのサービスで提供されます。これはセンサごとのベーとなる機能を表します。
UUID: 0x2100 + センサーの種類 (0x00~)
値はすべてリトルエンディアンです。

0x7100 + sensorType, 計測設定, read, write, senstick control serviceのステータスが停止,0x00の時のみ書き込めます。動作中に書き込んでも反映されません。
	1バイト uint8_t  センシング&ロギング設定フラグ。0x00: 停止 0x01: センシング有効, 0x03: センシング&ロギング有効(ログ取得が開始した時にデータを保存する)
	2バイト uint16_t サンプリングレート (ミリ秒), 10ミリ秒単位(最下位切り捨て) 0は無効(停止)
	2バイト uint16_t 測定レンジ。値の意味はセンサーごとに異なる。

0x7200 + sensorType, リアルタイムデータ, notification
	1バイト		有効データの数。 1以上。
	19バイト以下	データはセンサごとにフォーマットがあります。サンプリングごとに値が設定されます。	

0x7300 + sensorType, 読み出し対象ログID, write
	1バイト		 読み出し対象のログIDを指定します。データ無効なIDの場合は、メタデータおよびデータは0x00。
	2バイト uint16_t 読み出し縮退数。このNサンプルごとに大小切り替えで読み出します。通常データなら1を指定しておけば、1つづつデータ取り出し。
	4バイト uint32_t 読み出し位置。単位はバイトではなく、データのサンプル数です。

0x7400 + sensorType, ログメタデータ-, read, ログIDを書き込んだ後に更新されます
	1バイト uint8_t  log_id 読み出し終了している場合, ログIDが不正な場合は、 0xff
	2バイト uint16_t サンプリングレート (ミリ秒) 0は無効(停止)
	2バイト uint16_t 測定レンジ。値の意味はセンサーごとに異なる。
	4バイト uint32_t 有効なサンプル数。単位はバイトではなく、データのサンプル数です
	4バイト uint32_t 現在の読み出し位置。単位はバイトではなく、データのサンプル数です。
	4バイト uint32_t このセンサーのストレージ残量 (サンプル数)

0x7500 + sensorType, ログデータ, notification, ログIDを書き込んだ後、メタデータが通知されてから、データが送信されてきます。
	1バイト		有効データの数。 もう最後まで行ってデータがないときは、最後に0x00が設定されます。読み出し時にデータがなければ0x00が入っています。
	19バイト以下	データはセンサごとにフォーマットがあります。readもしくはnotifごとに勝手に読み出し位置が進みます。


== センサーの種類とデータフォーマット ==
    AccelerationSensor              = 0,
    GyroSensor                      = 1,
    MagneticFieldSensor             = 2,
    BrightnessSensor                = 3,
    UltraVioletSensor               = 4,
    HumidityAndTemperatureSensor    = 5,
    AirPressureSensor               = 6,

UUID: 0x2010, CBaseUUID: 0x7000
加速度 {uint16_t x, y, z}
レンジ	Sensitive scale factor
2 g	16384	LSB/g
4 g	8192	LSB/g
8 g	4096	LSB/g
16g	2048	LSB/g

UUID: 0x2011, CBaseUUID: 0x7010
角速度 {uint16_t x, y, z}
レンジ			Sensitivity scale factor
250 	deg/sec		131  LSB/(deg/s)
500	deg/sec		65.5 LSB/(deg/s)
1000	deg/sec		32.8 LSB/(deg/s)
2000	deg/sec		16.4 LSB/(deg/s)

UUID: 0x2012, CBaseUUID: 0x7020
地磁気 {uint16_t x, y, z} (有効ビットは14ビット。ファーム側で16ビットに符号拡張しています)。
14-bitモード, ±4900μT
0x1FFE (10進 8190)  4912 [uT]
0xE002 (10進 —8190) 4912 [uT]

UUID: 0x2013, CBaseUUID: 0x7030
照度 {uint16_t lux}
値はそのまま [lux]です

UUID: 0x2014, CBaseUUID: 0x7040
UVセンサー {uint16_t uv}
UVA 5 μW/cm2/step

UUID: 0x2015, CBaseUUID: 0x7050
温度及び湿度 {uint16_t t, humidity} (それぞれファームで符号拡張されています)
RH 12-bit T 14-bit, Disable on-chip heater, Disable OTP Reload
湿度 12-bit 0.04 %RH/LSB
温度 14-bit 0.01 deg/LSB

UUID: 0x2016, CBaseUUID: 0x7060
気圧 {uint24_t pressure}
センサーの生データ、リファレンスの内部差分は機能させていない。
4096LSB/hPa, なので、気圧 = 値 / 4096 [hPa]


TBD
- 電源が瞬断した場合、ログ終端が作れない→最後のところを
- 

TWIについての覚書
nrf_drvはハードウェアのラッパー。
コールバック関数を定義すると、ノンブロッキングモード。関数をNULLにしておくと、ブロッキングモード。
ノンブロッキングモードでバスの処理終了を待たずに関数を呼び出すと、BUSYでエラーが返ってくる。
app_twiはnrf_drv_twiのコールバックを構造化して個別に分配するもの+キューで処理を直列化する。ただキューに保持するデータが外部で確保されていることが必須。
バスの占有時間で処理ができることがメリットになるならば、採用する価値があるが。
10ミリ秒ごとに、400kHzで24バイトx3として1.4ミリ秒。今回はセンサーが3mAほど消費するから、プロセッサの消費電力低減に意味はなさそう。
ブロッキングで、メリットも、問題も、ないか。

ログのリーディング、書き込み中のを読み込んでいるときは、それを中断しとかないと、やばい?

